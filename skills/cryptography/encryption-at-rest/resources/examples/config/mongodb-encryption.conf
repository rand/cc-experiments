# MongoDB Encryption at Rest Configuration
#
# MongoDB supports native encryption at rest through:
# 1. Encrypted Storage Engine (MongoDB Enterprise)
# 2. Field-Level Encryption (Client-Side Field Level Encryption - CSFLE)
# 3. File system encryption (LUKS, eCryptfs)
#
# This configuration covers all three approaches.

# =============================================================================
# ENCRYPTED STORAGE ENGINE (ENTERPRISE ONLY)
# =============================================================================

# MongoDB configuration file (mongod.conf)
# Location: /etc/mongod.conf or C:\Program Files\MongoDB\Server\{version}\bin\mongod.cfg

# Enable encryption at rest
security:
  # Enable encryption
  enableEncryption: true

  # Encryption key management
  # Option 1: Local key file (for testing only)
  encryptionKeyFile: /path/to/secure/keyfile

  # Option 2: KMIP (Key Management Interoperability Protocol) - RECOMMENDED
  # kmip:
  #   serverName: kmip.example.com
  #   port: 5696
  #   clientCertificateFile: /path/to/client-cert.pem
  #   clientCertificatePassword: "password"
  #   serverCAFile: /path/to/ca.pem

# Encryption cipher mode (default: AES256-CBC)
# Options: AES256-CBC, AES256-GCM (MongoDB 4.4+)
storage:
  engine: wiredTiger
  wiredTiger:
    engineConfig:
      cacheSizeGB: 2
      # Encryption algorithm (AES256-CBC or AES256-GCM)
      # AES256-GCM provides authenticated encryption (recommended)
      encryptionCipherMode: AES256-GCM

# =============================================================================
# GENERATE ENCRYPTION KEY (LOCAL KEY FILE)
# =============================================================================

# Generate 32-byte (256-bit) random key
# IMPORTANT: For production, use KMIP instead of local key file

# Linux/macOS:
openssl rand -base64 32 > /path/to/secure/keyfile
chmod 600 /path/to/secure/keyfile
chown mongodb:mongodb /path/to/secure/keyfile

# Windows:
# Use MongoDB keyfile generator or OpenSSL for Windows

# =============================================================================
# KMIP CONFIGURATION (PRODUCTION RECOMMENDED)
# =============================================================================

# HashiCorp Vault as KMIP server
security:
  enableEncryption: true
  kmip:
    serverName: vault.example.com
    port: 5696
    clientCertificateFile: /etc/ssl/mongodb/client-cert.pem
    clientCertificatePassword: "secure_password"
    serverCAFile: /etc/ssl/mongodb/ca.pem
    # Use unique key per database or collection
    keyIdentifier: "mongodb-production-key"

# AWS KMS (via KMIP proxy)
# security:
#   enableEncryption: true
#   kmip:
#     serverName: kmip-proxy.example.com  # AWS KMS KMIP proxy
#     port: 5696
#     clientCertificateFile: /etc/ssl/mongodb/aws-client.pem
#     serverCAFile: /etc/ssl/mongodb/aws-ca.pem

# =============================================================================
# CLIENT-SIDE FIELD LEVEL ENCRYPTION (CSFLE)
# =============================================================================

# CSFLE encrypts specific fields before sending to MongoDB
# Provides fine-grained encryption control

# Key management setup (Node.js example)

const { MongoClient, ClientEncryption } = require('mongodb');

// AWS KMS configuration
const kmsProviders = {
  aws: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  }
};

// Customer Master Key (CMK) in AWS KMS
const customerMasterKey = {
  key: 'arn:aws:kms:us-east-1:123456789012:key/abcd1234-ab12-cd34-ef56-123456789012',
  region: 'us-east-1'
};

// Data Encryption Key (DEK) namespace
const keyVaultNamespace = 'encryption.__keyVault';

// Create Data Encryption Key
async function createDataKey() {
  const client = new MongoClient(process.env.MONGODB_URI);
  await client.connect();

  const encryption = new ClientEncryption(client, {
    keyVaultNamespace,
    kmsProviders
  });

  const dataKeyId = await encryption.createDataKey('aws', {
    masterKey: customerMasterKey,
    keyAltNames: ['users-encryption-key']
  });

  console.log('Data Key ID:', dataKeyId.toString('base64'));

  await client.close();
}

# Encryption schema (define which fields to encrypt)

const encryptionSchema = {
  bsonType: 'object',
  properties: {
    // Deterministic encryption (allows equality queries)
    email: {
      encrypt: {
        keyId: [Binary.createFromBase64('base64-encoded-data-key-id')],
        algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic',
        bsonType: 'string'
      }
    },
    // Random encryption (more secure, no queries)
    ssn: {
      encrypt: {
        keyId: [Binary.createFromBase64('base64-encoded-data-key-id')],
        algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Random',
        bsonType: 'string'
      }
    },
    creditCard: {
      encrypt: {
        keyId: [Binary.createFromBase64('base64-encoded-data-key-id')],
        algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Random',
        bsonType: 'string'
      }
    }
  }
};

# Connect with automatic encryption

const client = new MongoClient(process.env.MONGODB_URI, {
  autoEncryption: {
    keyVaultNamespace,
    kmsProviders,
    schemaMap: {
      'mydb.users': encryptionSchema
    }
  }
});

# Insert encrypted data (automatic)

await client.db('mydb').collection('users').insertOne({
  username: 'john_doe',
  email: 'john@example.com',      // Automatically encrypted
  ssn: '123-45-6789',              // Automatically encrypted
  creditCard: '4532-1234-5678-9010' // Automatically encrypted
});

# Query encrypted data (deterministic fields only)

const user = await client.db('mydb').collection('users').findOne({
  email: 'john@example.com'  // Automatic encryption + search
});

# =============================================================================
# PYTHON CLIENT-SIDE FIELD LEVEL ENCRYPTION
# =============================================================================

from pymongo import MongoClient
from pymongo.encryption import ClientEncryption
from bson.binary import Binary

# KMS providers
kms_providers = {
    'aws': {
        'accessKeyId': os.environ['AWS_ACCESS_KEY_ID'],
        'secretAccessKey': os.environ['AWS_SECRET_ACCESS_KEY']
    }
}

# Customer Master Key
customer_master_key = {
    'key': 'arn:aws:kms:us-east-1:123456789012:key/abcd1234',
    'region': 'us-east-1'
}

# Encryption options
auto_encryption_opts = {
    'key_vault_namespace': 'encryption.__keyVault',
    'kms_providers': kms_providers,
    'schema_map': {
        'mydb.users': {
            'bsonType': 'object',
            'properties': {
                'ssn': {
                    'encrypt': {
                        'keyId': [Binary.from_uuid(data_key_id)],
                        'algorithm': 'AEAD_AES_256_CBC_HMAC_SHA_512-Random',
                        'bsonType': 'string'
                    }
                }
            }
        }
    }
}

# Connect with auto-encryption
client = MongoClient(
    'mongodb://localhost:27017',
    auto_encryption_opts=auto_encryption_opts
)

# Data is automatically encrypted/decrypted
db = client.mydb
db.users.insert_one({
    'username': 'alice',
    'ssn': '111-22-3333'  # Automatically encrypted before sending
})

# =============================================================================
# KEY ROTATION
# =============================================================================

# Storage Engine Key Rotation (Enterprise)
# Use KMIP for automatic key rotation

# CSFLE Key Rotation (Manual process)

# 1. Create new Data Encryption Key
db.getSiblingDB('encryption').__keyVault.insertOne({
  _id: UUID(),
  keyAltNames: ['users-encryption-key-v2'],
  keyMaterial: Binary(...),  # Encrypted with CMK
  creationDate: ISODate(),
  updateDate: ISODate(),
  status: 1,
  masterKey: {
    provider: 'aws',
    key: 'arn:aws:kms:...',
    region: 'us-east-1'
  }
})

# 2. Re-encrypt data with new key (application-side)
# Load old key, decrypt data, encrypt with new key, update documents

# Python example:
for doc in collection.find({}):
    # Decrypt with old key
    decrypted_ssn = decrypt(doc['ssn'], old_key_id)
    # Encrypt with new key
    encrypted_ssn = encrypt(decrypted_ssn, new_key_id)
    # Update document
    collection.update_one(
        {'_id': doc['_id']},
        {'$set': {'ssn': encrypted_ssn, 'keyVersion': 2}}
    )

# =============================================================================
# FILESYSTEM ENCRYPTION (OS-LEVEL)
# =============================================================================

# LUKS encryption for MongoDB data directory (Linux)

# 1. Create encrypted volume
sudo cryptsetup luksFormat /dev/sdb1

# 2. Open encrypted volume
sudo cryptsetup luksOpen /dev/sdb1 mongodb_data

# 3. Create filesystem
sudo mkfs.ext4 /dev/mapper/mongodb_data

# 4. Mount
sudo mkdir -p /var/lib/mongodb/encrypted
sudo mount /dev/mapper/mongodb_data /var/lib/mongodb/encrypted

# 5. Set permissions
sudo chown -R mongodb:mongodb /var/lib/mongodb/encrypted

# 6. Update MongoDB data directory
# In mongod.conf:
storage:
  dbPath: /var/lib/mongodb/encrypted

# =============================================================================
# BACKUP ENCRYPTION
# =============================================================================

# Encrypted backup with mongodump

# Backup and encrypt
mongodump --uri="mongodb://localhost:27017/mydb" --archive | \
  openssl enc -aes-256-cbc -pbkdf2 -iter 100000 \
  -out backup_$(date +%Y%m%d).archive.enc

# Decrypt and restore
openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
  -in backup_20251027.archive.enc | \
  mongorestore --archive

# =============================================================================
# MONITORING AND AUDITING
# =============================================================================

# Enable audit logging (Enterprise)
auditLog:
  destination: file
  format: JSON
  path: /var/log/mongodb/audit.json
  filter: '{
    "atype": "authenticate",
    "param.db": "mydb"
  }'

# Monitor encryption status
use admin
db.runCommand({ getLog: "global" }).log.filter(
  line => line.includes("encryption")
)

# Check encryption configuration
db.serverStatus().encryptionAtRest

# =============================================================================
# PERFORMANCE TUNING
# =============================================================================

# WiredTiger cache size (larger for encrypted data)
storage:
  wiredTiger:
    engineConfig:
      # Increase cache for encryption overhead
      cacheSizeGB: 4  # 50% of RAM (vs 30% for unencrypted)

# Compression (works with encryption)
storage:
  wiredTiger:
    collectionConfig:
      blockCompressor: snappy  # or zstd, zlib

# =============================================================================
# COMPLIANCE NOTES
# =============================================================================

# GDPR:
#   - Encrypt PII (names, emails, addresses)
#   - Use CSFLE for field-level control
#   - Enable audit logging

# HIPAA:
#   - Encrypt PHI (Protected Health Information)
#   - Use AES-256-GCM
#   - Audit all access to encrypted data
#   - Enable at-rest and in-transit encryption

# PCI-DSS:
#   - Encrypt cardholder data
#   - Use CSFLE for credit card fields
#   - Rotate keys annually
#   - Never log decrypted data

# =============================================================================
# SECURITY BEST PRACTICES
# =============================================================================

# 1. Use KMIP with external key management system
#    - AWS KMS, HashiCorp Vault, or hardware HSM
#    - Never store keys on MongoDB servers

# 2. Enable TLS/SSL for data in transit
security:
  requireTLS: true
  clusterAuthMode: x509

# 3. Use different keys per collection or database
#    - Limit blast radius of key compromise

# 4. Enable authentication and authorization
security:
  authorization: enabled

# 5. Regular key rotation
#    - Quarterly for high-security environments
#    - Annually at minimum

# 6. Backup encryption keys separately
#    - Store in different location than data backups

# 7. Monitor for unauthorized access
#    - Enable audit logging
#    - Alert on encryption key access

# =============================================================================
# TESTING ENCRYPTION
# =============================================================================

# Verify encryption is active
use admin
db.runCommand({ serverStatus: 1 }).encryptionAtRest
# Should return: { enabled: true, ... }

# Test CSFLE
# Insert data and verify raw document is encrypted
db.users.insertOne({ ssn: '123-45-6789' })

# Check raw BSON (encrypted)
db.users.find().showRecordId()

# Verify decryption works
user = db.users.findOne({ username: 'john_doe' })
print(user.ssn)  # Should be decrypted automatically
