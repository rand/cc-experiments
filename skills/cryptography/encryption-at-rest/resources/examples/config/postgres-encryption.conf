# PostgreSQL Transparent Data Encryption (TDE) Configuration
#
# PostgreSQL doesn't have native TDE, but can use:
# 1. pgcrypto extension for column-level encryption
# 2. Encrypted file systems (LUKS, eCryptfs)
# 3. Third-party extensions (Cybertec PostgreSQL encryption)
#
# This configuration demonstrates pgcrypto setup and best practices.

# =============================================================================
# ENCRYPTION EXTENSION
# =============================================================================

# Enable pgcrypto extension in postgresql.conf
shared_preload_libraries = 'pgcrypto'

# =============================================================================
# DATABASE SETUP FOR ENCRYPTION
# =============================================================================

-- Connect as superuser
-- psql -U postgres

-- Create extension
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Verify installation
SELECT * FROM pg_available_extensions WHERE name = 'pgcrypto';

# =============================================================================
# TABLE-LEVEL ENCRYPTION SETUP
# =============================================================================

-- Create encrypted table
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL UNIQUE,

    -- Encrypted columns (store as BYTEA)
    email_encrypted BYTEA,
    ssn_encrypted BYTEA,
    credit_card_encrypted BYTEA,

    -- Metadata
    created_at TIMESTAMP DEFAULT NOW(),
    encryption_key_version INT DEFAULT 1
);

-- Indexes (on plaintext searchable fields only)
CREATE INDEX idx_users_username ON users(username);

# =============================================================================
# ENCRYPTION FUNCTIONS
# =============================================================================

-- Create encryption key table (store encrypted keys, not plaintext)
CREATE TABLE encryption_keys (
    version INT PRIMARY KEY,
    encrypted_key BYTEA NOT NULL,  -- Encrypted with master key from KMS
    algorithm VARCHAR(50) DEFAULT 'aes-256-gcm',
    created_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP
);

-- Insert key (encrypted by application using KMS)
INSERT INTO encryption_keys (version, encrypted_key)
VALUES (1, decode('base64_encoded_encrypted_key_from_kms', 'base64'));

-- Encryption function (symmetric AES-256-GCM)
-- In practice, application handles this to avoid keys in database
CREATE OR REPLACE FUNCTION encrypt_data(plaintext TEXT, key_version INT)
RETURNS BYTEA AS $$
DECLARE
    encryption_key BYTEA;
BEGIN
    -- Get encryption key (in practice, decrypt with KMS first)
    SELECT encrypted_key INTO encryption_key
    FROM encryption_keys
    WHERE version = key_version;

    IF encryption_key IS NULL THEN
        RAISE EXCEPTION 'Encryption key version % not found', key_version;
    END IF;

    -- Encrypt using pgcrypto (AES-256-CBC for simplicity)
    -- Note: Application-level encryption is preferred
    RETURN pgp_sym_encrypt(plaintext, encryption_key::TEXT);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Decryption function
CREATE OR REPLACE FUNCTION decrypt_data(ciphertext BYTEA, key_version INT)
RETURNS TEXT AS $$
DECLARE
    encryption_key BYTEA;
BEGIN
    SELECT encrypted_key INTO encryption_key
    FROM encryption_keys
    WHERE version = key_version;

    IF encryption_key IS NULL THEN
        RAISE EXCEPTION 'Encryption key version % not found', key_version;
    END IF;

    RETURN pgp_sym_decrypt(ciphertext, encryption_key::TEXT);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

# =============================================================================
# APPLICATION-LEVEL ENCRYPTION (RECOMMENDED APPROACH)
# =============================================================================

-- Application encrypts before INSERT
-- Python example:
-- from cryptography.fernet import Fernet
-- key = load_key_from_kms()
-- fernet = Fernet(key)
-- encrypted_email = fernet.encrypt(b"user@example.com")
-- cursor.execute("INSERT INTO users (username, email_encrypted) VALUES (%s, %s)",
--                ("john_doe", encrypted_email))

-- Application decrypts after SELECT
-- encrypted_email = row['email_encrypted']
-- plaintext_email = fernet.decrypt(encrypted_email).decode()

# =============================================================================
# VIEWS FOR TRANSPARENT DECRYPTION (APPLICATION-CONTROLLED)
# =============================================================================

-- Create view that decrypts on read (application provides key)
-- Note: This is for demonstration; in practice, application handles decryption
CREATE OR REPLACE VIEW users_decrypted AS
SELECT
    id,
    username,
    -- Application must set session variable with decryption key
    -- SET LOCAL app.encryption_key = 'base64_encoded_key';
    convert_from(
        decrypt(email_encrypted, decode(current_setting('app.encryption_key'), 'base64'), 'aes')::bytea,
        'UTF8'
    ) AS email,
    created_at
FROM users;

# =============================================================================
# KEY ROTATION
# =============================================================================

-- Add new key version
INSERT INTO encryption_keys (version, encrypted_key)
VALUES (2, decode('new_base64_encoded_encrypted_key', 'base64'));

-- Rotate encrypted columns (application-side recommended)
-- This is a simplified example; in practice, batch process:
UPDATE users
SET
    email_encrypted = encrypt_data(
        decrypt_data(email_encrypted, 1),  -- Decrypt with old key
        2                                   -- Encrypt with new key
    ),
    encryption_key_version = 2
WHERE encryption_key_version = 1;

# =============================================================================
# PERFORMANCE OPTIMIZATION
# =============================================================================

-- For searchable encrypted fields, use deterministic encryption
-- or store hash alongside encrypted value

-- Example: Email search
ALTER TABLE users ADD COLUMN email_hash CHAR(64);

-- Update hash on insert/update (application-side)
-- email_hash = hashlib.sha256(email.lower().encode()).hexdigest()

-- Create index on hash
CREATE INDEX idx_users_email_hash ON users(email_hash);

-- Search by hash (exact match only)
-- SELECT * FROM users WHERE email_hash = sha256('user@example.com');

# =============================================================================
# BACKUP ENCRYPTION
# =============================================================================

# Encrypt PostgreSQL backups with openssl

# Backup and encrypt
pg_dump -U postgres mydb | \
    openssl enc -aes-256-cbc -pbkdf2 -iter 100000 \
    -out backup_$(date +%Y%m%d).sql.enc

# Decrypt and restore
openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
    -in backup_20251027.sql.enc | \
    psql -U postgres mydb

# =============================================================================
# FILE SYSTEM ENCRYPTION (OS-LEVEL)
# =============================================================================

# LUKS encryption for PostgreSQL data directory
# (Run as root on Linux)

# 1. Create encrypted volume
sudo cryptsetup luksFormat /dev/sdb1

# 2. Open encrypted volume
sudo cryptsetup luksOpen /dev/sdb1 postgres_data

# 3. Create file system
sudo mkfs.ext4 /dev/mapper/postgres_data

# 4. Mount
sudo mkdir -p /var/lib/postgresql/encrypted
sudo mount /dev/mapper/postgres_data /var/lib/postgresql/encrypted

# 5. Set permissions
sudo chown -R postgres:postgres /var/lib/postgresql/encrypted

# 6. Update PostgreSQL data directory in postgresql.conf
data_directory = '/var/lib/postgresql/encrypted/data'

# 7. Auto-mount on boot (add to /etc/crypttab)
# postgres_data /dev/sdb1 none luks

# =============================================================================
# MONITORING AND AUDITING
# =============================================================================

-- Enable logging for encryption operations
log_statement = 'all'
log_line_prefix = '%t [%p]: user=%u,db=%d,app=%a,client=%h '

-- Audit encryption key access
CREATE TABLE encryption_audit (
    id SERIAL PRIMARY KEY,
    user_name VARCHAR(100),
    operation VARCHAR(50),  -- 'encrypt', 'decrypt', 'key_access'
    table_name VARCHAR(100),
    column_name VARCHAR(100),
    key_version INT,
    timestamp TIMESTAMP DEFAULT NOW(),
    client_ip INET
);

-- Audit trigger
CREATE OR REPLACE FUNCTION audit_encryption()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO encryption_audit (user_name, operation, table_name, key_version)
    VALUES (current_user, TG_OP, TG_TABLE_NAME, NEW.encryption_key_version);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_encryption_audit
AFTER INSERT OR UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION audit_encryption();

# =============================================================================
# COMPLIANCE NOTES
# =============================================================================

-- GDPR Compliance:
--   • Encrypt personal data (names, emails, addresses)
--   • Support "right to be forgotten" (DELETE operations)
--   • Log all access to encrypted data

-- HIPAA Compliance:
--   • Encrypt PHI (Protected Health Information)
--   • Use AES-256 or stronger
--   • Enable audit logging
--   • Automatic log retention (6 years)

-- PCI-DSS Compliance:
--   • Encrypt cardholder data (credit cards, CVVs)
--   • Never log decrypted card data
--   • Rotate keys annually
--   • Restrict key access to minimal roles

# =============================================================================
# SECURITY BEST PRACTICES
# =============================================================================

-- 1. Never store encryption keys in database
--    - Use KMS (AWS KMS, HashiCorp Vault)
--    - Or secure environment variables

-- 2. Use application-level encryption
--    - More control over key management
--    - Better performance (connection pooling)
--    - Easier key rotation

-- 3. Separate keys by data classification
--    - PII: One key
--    - Financial: Another key
--    - Medical: Another key

-- 4. Enable row-level security
CREATE POLICY user_isolation ON users
    USING (username = current_user);

ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- 5. Principle of least privilege
REVOKE ALL ON encryption_keys FROM PUBLIC;
GRANT SELECT ON encryption_keys TO app_role;  -- No INSERT/UPDATE/DELETE

# =============================================================================
# PERFORMANCE TESTING
# =============================================================================

-- Test encryption overhead
EXPLAIN ANALYZE
SELECT * FROM users WHERE username = 'john_doe';

-- Test decryption overhead (application-level preferred)
-- Measure: SELECT * FROM users; then decrypt in application

-- Benchmark: aim for <10% overhead for encrypted columns
